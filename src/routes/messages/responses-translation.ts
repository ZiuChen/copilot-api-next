import consola from 'consola'

import {
  type ResponsesPayload,
  type ResponseInputContent,
  type ResponseInputImage,
  type ResponseInputItem,
  type ResponseInputMessage,
  type ResponseInputReasoning,
  type ResponseInputText,
  type ResponsesResult,
  type ResponseOutputContentBlock,
  type ResponseOutputFunctionCall,
  type ResponseOutputItem,
  type ResponseOutputReasoning,
  type ResponseOutputRefusal,
  type ResponseOutputText,
  type ResponseReasoningBlock,
  type ResponseFunctionToolCallItem,
  type ResponseFunctionCallOutputItem,
  type Tool,
  type ToolChoiceFunction,
  type ToolChoiceOptions
} from '~/services/copilot/create-responses'

import {
  type AnthropicAssistantContentBlock,
  type AnthropicAssistantMessage,
  type AnthropicResponse,
  type AnthropicImageBlock,
  type AnthropicMessage,
  type AnthropicMessagesPayload,
  type AnthropicTextBlock,
  type AnthropicThinkingBlock,
  type AnthropicTool,
  type AnthropicToolResultBlock,
  type AnthropicToolUseBlock,
  type AnthropicUserContentBlock,
  type AnthropicUserMessage
} from './anthropic-types'

const MESSAGE_TYPE = 'message'
const CODEX_PHASE_MODEL = 'gpt-5.3-codex'

export const THINKING_TEXT = 'Thinking...'

// ==========================================================
// Request: Anthropic Messages → Responses API Payload
// ==========================================================

export function translateAnthropicMessagesToResponsesPayload(
  payload: AnthropicMessagesPayload
): ResponsesPayload {
  const input: ResponseInputItem[] = []

  for (const message of payload.messages) {
    input.push(...translateMessage(message, payload.model))
  }

  const translatedTools = convertAnthropicTools(payload.tools)
  const toolChoice = convertAnthropicToolChoice(payload.tool_choice)

  const { safetyIdentifier, promptCacheKey } = parseUserId(payload.metadata?.user_id)

  return {
    model: payload.model,
    input,
    instructions: translateSystemPrompt(payload.system, payload.model),
    temperature: 1, // reasoning requires high temperature
    top_p: payload.top_p ?? null,
    max_output_tokens: Math.max(payload.max_tokens, 12800),
    tools: translatedTools,
    tool_choice: toolChoice,
    metadata: payload.metadata ? { ...payload.metadata } : null,
    safety_identifier: safetyIdentifier,
    prompt_cache_key: promptCacheKey,
    stream: payload.stream ?? null,
    store: false,
    parallel_tool_calls: true,
    reasoning: {
      effort: 'high',
      summary: 'detailed'
    },
    include: ['reasoning.encrypted_content']
  }
}

// --- Message Translation ---

function translateMessage(message: AnthropicMessage, model: string): ResponseInputItem[] {
  if (message.role === 'user') {
    return translateUserMessage(message)
  }
  return translateAssistantMessage(message, model)
}

function translateUserMessage(message: AnthropicUserMessage): ResponseInputItem[] {
  if (typeof message.content === 'string') {
    return [createMessage('user', message.content)]
  }

  if (!Array.isArray(message.content)) return []

  const items: ResponseInputItem[] = []
  const pendingContent: ResponseInputContent[] = []

  for (const block of message.content) {
    if (block.type === 'tool_result') {
      flushPendingContent(pendingContent, items, { role: 'user' })
      items.push(createFunctionCallOutput(block))
      continue
    }

    const converted = translateUserContentBlock(block)
    if (converted) pendingContent.push(converted)
  }

  flushPendingContent(pendingContent, items, { role: 'user' })
  return items
}

function translateAssistantMessage(
  message: AnthropicAssistantMessage,
  model: string
): ResponseInputItem[] {
  const assistantPhase = resolveAssistantPhase(model, message.content)

  if (typeof message.content === 'string') {
    return [createMessage('assistant', message.content, assistantPhase)]
  }

  if (!Array.isArray(message.content)) return []

  const items: ResponseInputItem[] = []
  const pendingContent: ResponseInputContent[] = []

  for (const block of message.content) {
    if (block.type === 'tool_use') {
      flushPendingContent(pendingContent, items, {
        role: 'assistant',
        phase: assistantPhase
      })
      items.push(createFunctionToolCall(block))
      continue
    }

    if (block.type === 'thinking' && block.signature && block.signature.includes('@')) {
      flushPendingContent(pendingContent, items, {
        role: 'assistant',
        phase: assistantPhase
      })
      items.push(createReasoningContent(block))
      continue
    }

    const converted = translateAssistantContentBlock(block)
    if (converted) pendingContent.push(converted)
  }

  flushPendingContent(pendingContent, items, {
    role: 'assistant',
    phase: assistantPhase
  })
  return items
}

// --- Content Block Converters ---

function translateUserContentBlock(
  block: AnthropicUserContentBlock
): ResponseInputContent | undefined {
  switch (block.type) {
    case 'text':
      return createTextContent(block.text)
    case 'image':
      return createImageContent(block)
    default:
      return undefined
  }
}

function translateAssistantContentBlock(
  block: AnthropicAssistantContentBlock
): ResponseInputContent | undefined {
  switch (block.type) {
    case 'text':
      return createOutputTextContent(block.text)
    default:
      return undefined
  }
}

// --- Flush & Create Helpers ---

function flushPendingContent(
  pendingContent: ResponseInputContent[],
  target: ResponseInputItem[],
  message: Pick<ResponseInputMessage, 'role' | 'phase'>
): void {
  if (pendingContent.length === 0) return

  const messageContent = [...pendingContent]
  target.push(createMessage(message.role, messageContent, message.phase))
  pendingContent.length = 0
}

function createMessage(
  role: ResponseInputMessage['role'],
  content: string | ResponseInputContent[],
  phase?: ResponseInputMessage['phase']
): ResponseInputMessage {
  return {
    type: MESSAGE_TYPE,
    role,
    content,
    ...(role === 'assistant' && phase ? { phase } : {})
  }
}

function resolveAssistantPhase(
  model: string,
  content: AnthropicAssistantMessage['content']
): ResponseInputMessage['phase'] | undefined {
  if (!shouldApplyCodexPhase(model)) return undefined
  if (typeof content === 'string') return 'final_answer'
  if (!Array.isArray(content)) return undefined

  const hasText = content.some((block) => block.type === 'text')
  if (!hasText) return undefined

  const hasToolUse = content.some((block) => block.type === 'tool_use')
  return hasToolUse ? 'commentary' : 'final_answer'
}

const shouldApplyCodexPhase = (model: string): boolean => model === CODEX_PHASE_MODEL

function createTextContent(text: string): ResponseInputText {
  return { type: 'input_text', text }
}

function createOutputTextContent(text: string): ResponseInputText {
  return { type: 'output_text', text }
}

function createImageContent(block: AnthropicImageBlock): ResponseInputImage {
  return {
    type: 'input_image',
    image_url: `data:${block.source.media_type};base64,${block.source.data}`,
    detail: 'auto'
  }
}

function createReasoningContent(block: AnthropicThinkingBlock): ResponseInputReasoning {
  // Signature format: "encrypted_content@id"
  // Aligns with vscode-copilot-chat extractThinkingData
  const array = block.signature.split('@')
  const signature = array[0]
  const id = array[1]
  const thinking = block.thinking === THINKING_TEXT ? '' : block.thinking
  return {
    id,
    type: 'reasoning',
    summary: thinking ? [{ type: 'summary_text', text: thinking }] : [],
    encrypted_content: signature
  }
}

function createFunctionToolCall(block: AnthropicToolUseBlock): ResponseFunctionToolCallItem {
  return {
    type: 'function_call',
    call_id: block.id,
    name: block.name,
    arguments: JSON.stringify(block.input),
    status: 'completed'
  }
}

function createFunctionCallOutput(block: AnthropicToolResultBlock): ResponseFunctionCallOutputItem {
  return {
    type: 'function_call_output',
    call_id: block.tool_use_id,
    output: convertToolResultContent(block.content),
    status: block.is_error ? 'incomplete' : 'completed'
  }
}

// --- System Prompt ---

function translateSystemPrompt(
  system: string | AnthropicTextBlock[] | undefined,
  _model: string
): string | null {
  if (!system) return null

  if (typeof system === 'string') {
    return system
  }

  const text = system.map((block) => block.text).join(' ')

  return text.length > 0 ? text : null
}

// --- Tool Conversion ---

function convertAnthropicTools(tools: AnthropicTool[] | undefined): Tool[] | null {
  if (!tools || tools.length === 0) return null

  return tools.map((tool) => ({
    type: 'function' as const,
    name: tool.name,
    parameters: tool.input_schema,
    strict: false,
    ...(tool.description ? { description: tool.description } : {})
  }))
}

function convertAnthropicToolChoice(
  choice: AnthropicMessagesPayload['tool_choice']
): ToolChoiceOptions | ToolChoiceFunction {
  if (!choice) return 'auto'

  switch (choice.type) {
    case 'auto':
      return 'auto'
    case 'any':
      return 'required'
    case 'tool':
      return choice.name ? { type: 'function', name: choice.name } : 'auto'
    case 'none':
      return 'none'
    default:
      return 'auto'
  }
}

// --- Tool Result Content ---

function convertToolResultContent(
  content: string | Array<AnthropicTextBlock | AnthropicImageBlock>
): string | ResponseInputContent[] {
  if (typeof content === 'string') return content

  if (Array.isArray(content)) {
    const result: ResponseInputContent[] = []
    for (const block of content) {
      switch (block.type) {
        case 'text':
          result.push(createTextContent(block.text))
          break
        case 'image':
          result.push(createImageContent(block))
          break
        default:
          break
      }
    }
    return result
  }

  return ''
}

// --- User ID Parsing ---

function parseUserId(userId: string | undefined): {
  safetyIdentifier: string | null
  promptCacheKey: string | null
} {
  if (!userId || typeof userId !== 'string') {
    return { safetyIdentifier: null, promptCacheKey: null }
  }

  const userMatch = userId.match(/user_([^_]+)_account/)
  const safetyIdentifier = userMatch ? userMatch[1] : null

  const sessionMatch = userId.match(/_session_(.+)$/)
  const promptCacheKey = sessionMatch ? sessionMatch[1] : null

  return { safetyIdentifier, promptCacheKey }
}

// ==========================================================
// Response: Responses API Result → Anthropic Response
// ==========================================================

export function translateResponsesResultToAnthropic(response: ResponsesResult): AnthropicResponse {
  const contentBlocks = mapOutputToAnthropicContent(response.output)
  const usage = mapResponsesUsage(response)
  let anthropicContent = fallbackContentBlocks(response.output_text)
  if (contentBlocks.length > 0) {
    anthropicContent = contentBlocks
  }

  return {
    id: response.id,
    type: 'message',
    role: 'assistant',
    content: anthropicContent,
    model: response.model,
    stop_reason: mapResponsesStopReason(response),
    stop_sequence: null,
    usage
  }
}

function mapOutputToAnthropicContent(
  output: ResponseOutputItem[]
): AnthropicAssistantContentBlock[] {
  const contentBlocks: AnthropicAssistantContentBlock[] = []

  for (const item of output) {
    switch (item.type) {
      case 'reasoning': {
        const thinkingText = extractReasoningText(item)
        if (thinkingText.length > 0) {
          contentBlocks.push({
            type: 'thinking',
            thinking: thinkingText,
            signature: (item.encrypted_content ?? '') + '@' + item.id
          })
        }
        break
      }
      case 'function_call': {
        const toolUseBlock = createToolUseContentBlock(item)
        if (toolUseBlock) contentBlocks.push(toolUseBlock)
        break
      }
      case 'message': {
        const combinedText = combineMessageTextContent(item.content)
        if (combinedText.length > 0) {
          contentBlocks.push({ type: 'text', text: combinedText })
        }
        break
      }
      default: {
        const combinedText = combineMessageTextContent(
          (item as { content?: ResponseOutputContentBlock[] }).content
        )
        if (combinedText.length > 0) {
          contentBlocks.push({ type: 'text', text: combinedText })
        }
      }
    }
  }

  return contentBlocks
}

function combineMessageTextContent(content: ResponseOutputContentBlock[] | undefined): string {
  if (!Array.isArray(content)) return ''

  let aggregated = ''
  for (const block of content) {
    if (isResponseOutputText(block)) {
      aggregated += block.text
    } else if (isResponseOutputRefusal(block)) {
      aggregated += block.refusal
    } else if (typeof (block as { text?: unknown }).text === 'string') {
      aggregated += (block as { text: string }).text
    } else if (typeof (block as { reasoning?: unknown }).reasoning === 'string') {
      aggregated += (block as { reasoning: string }).reasoning
    }
  }

  return aggregated
}

function extractReasoningText(item: ResponseOutputReasoning): string {
  // Compatible with opencode: filter out empty thinking blocks
  if (!item.summary || item.summary.length === 0) {
    return THINKING_TEXT
  }

  const segments: string[] = []
  const collectFromBlocks = (blocks?: ResponseReasoningBlock[]) => {
    if (!Array.isArray(blocks)) return
    for (const block of blocks) {
      if (typeof block.text === 'string') {
        segments.push(block.text)
      }
    }
  }

  collectFromBlocks(item.summary)
  return segments.join('').trim()
}

function createToolUseContentBlock(call: ResponseOutputFunctionCall): AnthropicToolUseBlock | null {
  const toolId = call.call_id
  if (!call.name || !toolId) return null

  return {
    type: 'tool_use',
    id: toolId,
    name: call.name,
    input: parseFunctionCallArguments(call.arguments)
  }
}

function parseFunctionCallArguments(rawArguments: string): Record<string, unknown> {
  if (typeof rawArguments !== 'string' || rawArguments.trim().length === 0) {
    return {}
  }

  try {
    const parsed: unknown = JSON.parse(rawArguments)
    if (Array.isArray(parsed)) return { arguments: parsed }
    if (parsed && typeof parsed === 'object') {
      return parsed as Record<string, unknown>
    }
  } catch (error) {
    consola.warn('Failed to parse function call arguments', {
      error,
      rawArguments
    })
  }

  return { raw_arguments: rawArguments }
}

function fallbackContentBlocks(outputText: string): AnthropicAssistantContentBlock[] {
  if (!outputText) return []
  return [{ type: 'text', text: outputText }]
}

function mapResponsesStopReason(response: ResponsesResult): AnthropicResponse['stop_reason'] {
  const { status, incomplete_details: incompleteDetails } = response

  if (status === 'completed') {
    if (response.output.some((item) => item.type === 'function_call')) {
      return 'tool_use'
    }
    return 'end_turn'
  }

  if (status === 'incomplete') {
    if (incompleteDetails?.reason === 'max_output_tokens') {
      return 'max_tokens'
    }
    if (incompleteDetails?.reason === 'content_filter') {
      return 'end_turn'
    }
  }

  return null
}

function mapResponsesUsage(response: ResponsesResult): AnthropicResponse['usage'] {
  const inputTokens = response.usage?.input_tokens ?? 0
  const outputTokens = response.usage?.output_tokens ?? 0
  const inputCachedTokens = response.usage?.input_tokens_details?.cached_tokens

  return {
    input_tokens: inputTokens - (inputCachedTokens ?? 0),
    output_tokens: outputTokens,
    ...(inputCachedTokens !== undefined && {
      cache_read_input_tokens: inputCachedTokens
    })
  }
}

// --- Type Guards ---

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === 'object' && value !== null

const isResponseOutputText = (block: ResponseOutputContentBlock): block is ResponseOutputText =>
  isRecord(block) && 'type' in block && (block as { type?: unknown }).type === 'output_text'

const isResponseOutputRefusal = (
  block: ResponseOutputContentBlock
): block is ResponseOutputRefusal =>
  isRecord(block) && 'type' in block && (block as { type?: unknown }).type === 'refusal'
